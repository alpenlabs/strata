use std::{
    fs::{self, File},
    path::Path,
    time::Duration,
};

use anyhow::Result;
use arbitrary::Arbitrary;
use borsh::{BorshDeserialize, BorshSerialize};
use serde::{Deserialize, Serialize};

use crate::VerificationKey;

/// Validity proof generated by the `ZkVmHost`
#[derive(
    Debug, Clone, Serialize, Deserialize, BorshSerialize, BorshDeserialize, PartialEq, Eq, Arbitrary,
)]
pub struct Proof(Vec<u8>);

impl Proof {
    pub fn new(data: Vec<u8>) -> Self {
        Self(data)
    }

    pub fn as_bytes(&self) -> &[u8] {
        &self.0
    }

    pub fn is_empty(&self) -> bool {
        self.0.is_empty()
    }
}

impl From<Proof> for Vec<u8> {
    fn from(value: Proof) -> Self {
        value.0
    }
}

impl From<&Proof> for Vec<u8> {
    fn from(value: &Proof) -> Self {
        value.0.clone()
    }
}

/// An input to the aggregation program.
///
/// Consists of a proof and a verification key.
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct AggregationInput {
    proof: Proof,
    vk: VerificationKey,
}

impl AggregationInput {
    pub fn new(proof: Proof, vk: VerificationKey) -> Self {
        Self { proof, vk }
    }

    pub fn proof(&self) -> &Proof {
        &self.proof
    }

    pub fn vk(&self) -> &VerificationKey {
        &self.vk
    }
}

#[derive(Debug, Clone, Copy)]
pub enum ProofType {
    Groth16,
    Core,
    Compressed,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ProofWithInfo {
    pub proof: Proof,
    pub info: ProofInfo,
}

#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub struct ProofInfo {
    cycle_count: u64,
    duration: Duration,
}

impl ProofInfo {
    pub fn new(cycle_count: u64, duration: Duration) -> Self {
        Self {
            cycle_count,
            duration,
        }
    }
}

impl ProofWithInfo {
    pub fn new(proof: Proof, info: ProofInfo) -> Self {
        Self { proof, info }
    }

    pub fn proof(&self) -> &Proof {
        &self.proof
    }

    pub fn cycle_count(&self) -> u64 {
        self.info.cycle_count
    }

    pub fn duration(&self) -> Duration {
        self.info.duration
    }

    /// Saves the proof to a path.
    pub fn save(&self, path: impl AsRef<Path>) -> Result<()> {
        let path = path.as_ref();
        if let Some(parent) = path.parent() {
            // Create the parent directories if they don't exist
            fs::create_dir_all(parent)?;
        }
        bincode::serialize_into(File::create(path).expect("failed to open file"), self)
            .map_err(Into::into)
    }

    /// Loads a proof from a path.
    pub fn load(path: impl AsRef<Path>) -> Result<Self> {
        bincode::deserialize_from(File::open(path).expect("failed to open file"))
            .map_err(Into::into)
    }
}
