use core::fmt;

use arbitrary::Arbitrary;
use borsh::{BorshDeserialize, BorshSerialize};
use serde::{de::DeserializeOwned, Deserialize, Serialize};

/// Validity proof generated by the `ZKVMHost`
#[derive(
    Debug, Clone, Serialize, Deserialize, BorshSerialize, BorshDeserialize, PartialEq, Eq, Arbitrary,
)]
pub struct Proof(Vec<u8>);

impl Proof {
    pub fn new(data: Vec<u8>) -> Self {
        Self(data)
    }

    pub fn as_bytes(&self) -> &[u8] {
        &self.0
    }

    pub fn is_empty(&self) -> bool {
        self.0.is_empty()
    }
}

impl From<Proof> for Vec<u8> {
    fn from(value: Proof) -> Self {
        value.0
    }
}

impl From<&Proof> for Vec<u8> {
    fn from(value: &Proof) -> Self {
        value.0.clone()
    }
}

/// Verification Key required to verify proof generated from `ZKVMHost`
#[derive(
    Debug, Clone, Serialize, Deserialize, BorshSerialize, BorshDeserialize, PartialEq, Eq, Arbitrary,
)]
pub struct VerificationKey(pub Vec<u8>);

impl VerificationKey {
    pub fn new(data: Vec<u8>) -> Self {
        Self(data)
    }

    pub fn as_bytes(&self) -> &[u8] {
        &self.0
    }
}

/// Prover config of the ZKVM Host
#[derive(Debug, Clone, Copy)]
pub struct ProverOptions {
    pub enable_compression: bool,
    pub use_mock_prover: bool,
    pub stark_to_snark_conversion: bool,
    pub use_cached_keys: bool,
}

// Compact representation of the prover options
// Can be used to identify the saved proofs
impl fmt::Display for ProverOptions {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let mut has_flags = false;

        if self.enable_compression {
            write!(f, "c")?;
            has_flags = true;
        }

        if self.use_mock_prover {
            write!(f, "m")?;
            has_flags = true;
        }

        if self.stark_to_snark_conversion {
            write!(f, "s")?;
            has_flags = true;
        }

        if has_flags {
            write!(f, "_")?;
        }

        Ok(())
    }
}

/// A trait for managing inputs to a ZKVM prover. This trait provides methods for
/// adding inputs in various formats to be used during the proof generation process.
pub trait ZKVMInputBuilder<'a> {
    type Input;

    /// Creates a new instance of the `ProverInputs` struct.
    fn new() -> Self;

    /// Serializes the given item using Serde and appends it to the list of inputs.
    fn write<T: serde::Serialize>(&mut self, item: &T) -> anyhow::Result<&mut Self>;

    /// Serializes the given item using the Borsh serialization format and appends
    /// it to the list of inputs.
    fn write_borsh<T: borsh::BorshSerialize>(&mut self, item: &T) -> anyhow::Result<&mut Self>;

    /// Appends a pre-serialized byte array to the list of inputs.
    ///
    /// This method is intended for cases where the data has already been serialized
    /// outside of the zkVM's standard serialization methods. It allows you to provide
    /// serialized inputs directly, bypassing any further serialization.
    fn write_serialized(&mut self, item: &[u8]) -> anyhow::Result<&mut Self>;

    /// Adds an `AggregationInput` to the list of aggregation/composition inputs.
    ///
    /// This method is specifically used for cases where proof aggregation or composition
    /// is involved, allowing for proof and verification inputs to be provided to the zkVM.
    fn write_proof(&mut self, item: AggregationInput) -> anyhow::Result<&mut Self>;

    fn build(&mut self) -> anyhow::Result<Self::Input>;
}

/// A trait implemented by the prover ("host") of a zkVM program.
pub trait ZKVMHost: Send + Sync + Clone {
    type Input<'a>: ZKVMInputBuilder<'a>;

    /// Initializes the ZKVM with the provided ELF program and prover configuration.
    fn init(guest_code: Vec<u8>, prover_options: ProverOptions) -> Self;

    /// Executes the guest code within the VM, generating and returning the validity proof.
    // TODO: Consider using custom error types instead of a generic error to capture the different
    // reasons proving can fail.
    fn prove<'a>(
        &self,
        input: <Self::Input<'a> as ZKVMInputBuilder<'a>>::Input,
    ) -> anyhow::Result<(Proof, VerificationKey)>;

    /// Reuturns the Verification key for the loaded ELF program
    fn get_verification_key(&self) -> VerificationKey;
}

/// A trait implemented by a verifier to decode and verify the proof generated by the prover
/// ("host").
pub trait ZKVMVerifier {
    /// Verifies the proof generated by the prover against the `program_id`.
    fn verify(verification_key: &VerificationKey, proof: &Proof) -> anyhow::Result<()>;

    /// Verifies the proof generated by the prover against the given `program_id` and
    /// `public_params`.
    fn verify_with_public_params<T: Serialize + DeserializeOwned>(
        verification_key: &VerificationKey,
        public_params: T,
        proof: &Proof,
    ) -> anyhow::Result<()>;

    fn verify_groth16(
        proof: &Proof,
        verification_key: &[u8],
        public_params_raw: &[u8],
    ) -> anyhow::Result<()>;

    /// Extracts the public output from the given proof using standard `serde`
    /// serialization/deserialization.
    fn extract_public_output<T: Serialize + DeserializeOwned>(proof: &Proof) -> anyhow::Result<T>;

    /// Extracts the public output from the given proof assuming the data was serialized using
    /// Borsh.
    fn extract_borsh_public_output<T: BorshSerialize + BorshDeserialize>(
        proof: &Proof,
    ) -> anyhow::Result<T>;
}

impl Default for ProverOptions {
    fn default() -> Self {
        Self {
            enable_compression: false,
            use_mock_prover: true,
            stark_to_snark_conversion: false,
            use_cached_keys: true,
        }
    }
}

/// An input to the aggregation program.
///
/// Consists of a proof and a verification key.
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct AggregationInput {
    proof: Proof,
    vk: VerificationKey,
}

impl AggregationInput {
    pub fn new(proof: Proof, vk: VerificationKey) -> Self {
        Self { proof, vk }
    }

    pub fn proof(&self) -> &Proof {
        &self.proof
    }

    pub fn vk(&self) -> &VerificationKey {
        &self.vk
    }
}

/// A trait representing a Zero-Knowledge Virtual Machine (ZkVM) interface.
/// Provides methods for reading inputs, committing outputs, and verifying proofs
/// within the ZkVM environment.
pub trait ZkVm {
    /// Reads a serialized object from the guest code, deserializing it using Serde.
    ///
    /// The input is expected to be written with [`ZKVMInputBuilder::write`].
    fn read<T: DeserializeOwned>(&self) -> T;

    /// Reads a serialized byte slice from the guest code.
    ///
    /// The input is expected to be written with [`ZKVMInputBuilder::write_serialized`].
    fn read_slice(&self) -> Vec<u8>;

    /// Commits a Serde-serializable object to the public values stream.
    ///
    /// Values that are committed can be proven as public parameters.
    fn commit<T: Serialize>(&self, output: &T);

    /// Commits a pre-serialized byte slice to the public values stream.
    ///
    /// This method is intended for cases where the data has already been serialized
    /// outside of the ZkVM's standard serialization methods. It allows you to provide
    /// serialized outputs directly, bypassing any further serialization.
    fn commit_slice(&self, raw_output: &[u8]);

    /// Verifies a proof generated with the ZkVM.
    ///
    /// This method checks the validity of the proof against the provided verification key digest
    /// and public values. It will panic if the proof fails to verify.
    fn verify_proof(&self, vk_digest: &[u32; 8], public_values: &[u8]);

    /// Verifies a Groth16 proof.
    ///
    /// # Parameters
    ///
    /// * `proof`: A byte slice containing the serialized proof. (TODO: Change `proof: &[u8]` to a
    ///   `Proof` type.)
    /// * `verification_key`: A byte slice containing the serialized verification key.
    /// * `public_params_raw`: A byte slice containing the serialized public parameters.
    ///
    /// # Returns
    ///
    /// Returns `Ok(())` if the proof verifies successfully, or an `anyhow::Error` if verification
    /// fails.
    fn verify_groth16(
        &self,
        proof: &[u8],
        verification_key: &[u8],
        public_params_raw: &[u8],
    ) -> anyhow::Result<()>;

    /// Reads a Borsh-serialized object from the guest code.
    ///
    /// The input is expected to be written with [`ZKVMInputBuilder::write_borsh`].
    fn read_borsh<T: BorshSerialize + BorshDeserialize>(&self) -> T {
        let slice = self.read_slice();
        borsh::from_slice(&slice).expect("borsh serialization failed")
    }

    /// Commits a Borsh-serializable object to the public values stream.
    ///
    /// Values that are committed can be proven as public parameters.
    fn commit_borsh<T: BorshSerialize + BorshDeserialize>(&self, output: &T) {
        self.commit_slice(&borsh::to_vec(output).expect("failed borsh serialization"));
    }

    /// Reads and verifies a committed output from another guest function, deserializing it using
    /// Serde.
    ///
    /// This function is meant to read the committed output of another guest function
    /// that was written with [`ZkVm::commit`].
    /// It then verifies the proof against the given verification key digest.
    ///
    /// This is equivalent to calling [`ZkVm::read`] and [`ZkVm::verify_proof`], but avoids double
    /// serialization and deserialization. The function will panic if the proof fails to verify.
    fn read_verified<T: DeserializeOwned>(&self, vk_digest: &[u32; 8]) -> T {
        let public_values_raw = self.read_slice();
        self.verify_proof(vk_digest, &public_values_raw);
        bincode::deserialize(&public_values_raw).expect("failed bincode deserialization")
    }

    /// Reads and verifies a committed output from another guest function, deserializing it using
    /// Borsh.
    ///
    /// This function is similar to [`ZkVm::read_verified`], but is intended for guest commitments
    /// committed via [`ZkVm::commit_borsh`]. The output is expected to be Borsh-serializable.
    /// It then verifies the proof using the internal verification key context.
    ///
    /// This is equivalent to calling [`ZkVm::read_borsh`] and [`ZkVm::verify_proof`], but avoids
    /// double serialization and deserialization. The function will panic if the proof fails to
    /// verify.
    fn read_verified_borsh<T: BorshSerialize + BorshDeserialize>(&self, vk_digest: &[u32; 8]) -> T {
        let public_values_raw = self.read_slice();
        self.verify_proof(vk_digest, &public_values_raw);
        borsh::from_slice(&public_values_raw).expect("failed borsh deserialization")
    }
}
